import json
import math
from sys import argv


def load_latlong():
    """
    Load os3e_latlong.json
    """
    latlong = {}
    with open("./os3e_env_conf/os3e_latlong.json", mode="rt", encoding="utf-8") as f:
        latlong_json = json.load(f)

    return latlong_json

def load_link():
    """
    Load os3e_link.json
    """
    link_json = {}
    with open("./os3e_env_conf/os3e_link.json", mode="rt", encoding="utf-8") as f:
        link_json = json.load(f)

    return link_json

def get_delay(lat1, long1, lat2, long2):
    first_product = math.sin(float(lat1)) * math.sin(float(lat2))
    second_product_first_part = math.cos(float(lat1)) * math.cos(float(lat2))
    second_product_second_part = math.cos((float(long2)) - (float(long1)))
    distance = math.radians(math.acos(first_product + (second_product_first_part * second_product_second_part))) * 6378.137
    # t (in ms) = ( distance in km * 1000 (for meters) ) / ( speed of light / 1000 (for ms))
    # t         = ( distance       * 1000              ) / ( 1.97 * 10**8   / 1000         )
    # delay = "'" + (str((distance * 1000) / 197000)) + "ms'"
    delay = (distance * 1000) / 197000
    return delay

nodes = load_latlong()
links = load_link()

# ==================================================================================

name = "os3e"

ip_host_base = 0
ip_switch_base = 7

# Enable ssh access for host nodes
enable_ssh = 0

for i in range(len(argv)):
    if argv[i] == '--ssh':
        enable_ssh = 1

# Define string fragments for output later on
outputstring_1 = '''#!/usr/bin/python

"""
Custom topology for Mininet, generated by GraphML-Topo-to-Mininet-Network-Generator.
"""

from mininet.net import Mininet
from mininet.node import CPULimitedHost, Host
# from mininet.cli import CLI
from mininet.log import setLogLevel, info
from mininet.link import TCLink
from subprocess import call
import time
from lib.node import P4SimpleSwitch
from lib.json import load_switch_ip_list, write_nodes_json
from lib import cli

        
def myNetwork():

    net = Mininet( topo=None,
                   build=False,
                #    ipBase='10.0.0.0/12',
                   ipBase='10.0.0.0/24',
                #    autoSetMacs = True
                 )

    switch_ip_list = load_switch_ip_list("{name}_switch_ip_list.json")
'''

outputstring_2a='''
    info( '\033[1;36m*** Add P4 switches\033[0m\\n')\n
'''
outputstring_2b='''
    info( '\033[1;36m*** Add hosts\033[0m\\n')\n
'''

outputstring_2c='''
    info( '\033[1;36m*** Add P4 controllers\033[0m\\n')\n
'''

outputstring_2d='''
    info( '\033[1;36m*** Add links\033[0m\\n')\n
'''

outputstring_2e='''
    info( '\033[1;36m*** Add Dummy and p4runtime links\033[0m\\n')\n
'''

outputstring_3a='''
    info( '\\n\033[1;36m*** Starting network\033[0m\\n')
    net.build()
    cli.set_mtu(net)\n
'''

outputstring_3b='''
    info( '\033[1;36m*** Run simple_switch_grpc\033[0m\\n')\n
'''

outputstring_write_nodes_json = '''
    info( '\\n\033[1;36m*** Write nodes.json \033[0m\\n')
    write_nodes_json(net)\n
'''

outputstring_3c='''
    info( '\033[1;36m*** Set vtysh config\033[0m\\n')\n
'''

outputstring_3d='''
    info( '\033[1;36m*** Set P4 runtime\033[0m\\n')\n
'''

user_simulation_code_area='''
    ####################################
    #### USER SIMULATION CODE HERE #####
    ####################################
    
    # Your automatic simulation code.
    
    ####################################
'''

outputstring_4c='''
    cli.P4CLI(net)
'''

outputstring_4d='''
    net.stop()

if __name__ == '__main__':
    setLogLevel( 'info' )
    myNetwork()
'''

outputstring_5 = '''
'''

# WHERE TO PUT RESULTS
outputstring_to_be_exported = ''
outputstring_to_be_exported += outputstring_1.format(name=name)

# STRING CREATION
# FIRST CREATE THE SWITCHES AND HOSTS
tempstring1 = ''
tempstring2 = ''
tempstring3 = ''
tempstring4 = ''
tempstring5 = ''
tempstring6 = ''
tempstring7 = ''
tempstring8 = ''
tempstring9 = ''
local_link_flag = 1
address_list = {}
node_name_id_dict = {}  # ket=node_name, value=id

for i, v in enumerate(nodes):
    node_name = v['node']
    node_name_id_dict[node_name] = str(i+1)

# Create switch
    temp1 =  '    '
    temp1 += node_name
    temp1 += " = net.addSwitch('s"
    temp1 += str(i+1)
    temp1 += "', cls=P4SimpleSwitch)\n"

    # Create corresponding host
    temp2 =  '    '
    temp2 += node_name
    temp2 += "_host = net.addHost('h"
    temp2 += str((i+1))
    # if i % 254 == 0:
    #     ip_host_base = ip_host_base + 1
    temp2 += "', cls=Host, ip=None"
    temp2 += ")\n"
    tempstring1 += temp1
    tempstring2 += temp2


    linkname = '    local_link'
    value = " = {'bw':1000.0, 'delay':'0ms'}\n"
    if local_link_flag:
        tempstring3 += linkname
        tempstring3 += value
        local_link_flag = 0
    temp3 =  '    net.addLink('
    temp3 += node_name
    temp3 += ', '
    temp3 += node_name
    temp3 += "_host, "
    temp3 += "params2={'ip': '10."
    if i % 254 == 0:
        ip_host_base = ip_host_base + 1
    temp3 += str(ip_host_base)
    temp3 += '.'
    temp3 += str(i % 254 + 1)
    temp3 += '.2'
    temp3 += "/24'}, cls=TCLink, **"
    temp3 += "local_link"
    temp3 += ")"
    temp3 += '\n'
    tempstring3 += temp3

    ipv6_str1 = str(hex(ip_host_base))[2:]
    ipv6_hex2 = hex((i % 254 + 1))
    ipv6_str2 = str(ipv6_hex2)[2:]
    switch_ipv6 =f"fc00::{ipv6_str1}:{ipv6_str2}:1:0:0/80"
    host_ipv6 = f"fc00::{ipv6_str1}:{ipv6_str2}:2:0:0/80"

    cmd_temp4_ipv4 = 'f"' + 'ip route add default dev {' + f'{node_name}_host.intfNames()[0]' + '}' + '"'
    temp4 =  f'    {node_name}_host.cmd('
    temp4 += f'{cmd_temp4_ipv4})\n'
    
    cmd_temp4_ipv6 = 'f"' + f'ip -6 addr add {host_ipv6} dev ' + '{' + f'{node_name}_host.intfNames()[0]' + '}' + '"'
    temp4 +=  f'    {node_name}_host.cmd('
    temp4 += f'{cmd_temp4_ipv6})\n'

    cmd_temp4_ipv6_default_route = 'f"' + 'ip -6 route add default dev ' + '{' + f'{node_name}_host.intfNames()[0]' + '}' + '"'
    temp4 +=  f'    {node_name}_host.cmd('
    temp4 += f'{cmd_temp4_ipv6_default_route})\n\n'
    tempstring4 += temp4

    # Create controller
    temp5 = '    '
    temp5 += f"{node_name}_Controller"
    temp5 += f" = {node_name}.add_P4Controller(net, "
    temp5 += f"switch_ip_list[{node_name}.name])\n"
    tempstring5 += temp5

    temp6 = '    '
    temp6 += f"{node_name}.reflect_switch_links()\n"
    tempstring6 += temp6

    # Run Simple Switch
    temp7 = '    '
    temp7 += f"{node_name}.run_simple_switch_grpc()\n"
    tempstring7 += temp7

    # Set vtysh config ospf
    temp8 = '    '
    temp8 += f"{node_name}_Controller.set_frr_ospf_conf()\n"
    tempstring8 += temp8

    # Run P4 runtime
    temp9 = '    '
    temp9 += f"{node_name}_Controller.run_p4_runtime_shell()\n"
    tempstring9 += temp9

    # Create address list
    address_list = address_list | {f"s{str(i+1)}": {
        f"h{str((i+1))}": {
            "ip": f"10.{ip_host_base}.{(i % 254 + 1)}.1/24",
            "ipv6": switch_ipv6,
            "bw": 1000.0
        }
    }}


outputstring_to_be_exported += outputstring_2a
outputstring_to_be_exported += tempstring1
outputstring_to_be_exported += outputstring_2b
outputstring_to_be_exported += tempstring2
outputstring_to_be_exported += outputstring_2c
outputstring_to_be_exported += tempstring5
outputstring_to_be_exported += outputstring_2d

tempstring3 += '\n'
outputstring_to_be_exported += tempstring3

tempstring4 += '\n'
outputstring_to_be_exported += tempstring4

tempstringController = outputstring_3c
tempstringController += tempstring8 + '\n'
tempstringController += outputstring_3d
tempstringController += tempstring9


tempstring4 = ''
ip_switch_link_base = 3
ip_switch_link_index = 0

for i, v in enumerate(links):
    src_node = v['from']
    dst_node = v['to']
    capacity = v['capacity']
    metric = v['metric']
    delay = v['delay']*1000  # convert to ms
    queue = v['queue']

    src_id = node_name_id_dict[src_node]
    dst_id = node_name_id_dict[dst_node]

    citylinknum = i + 1
    # Link all corresponding switches with each other
    linkname = '    CityLink' + str(citylinknum)
    # value = " = {'bw':" + str(1000.0) + ", 'delay':'" + str(delay) + "ms'}\n"
    value = " = {'delay':'" + str(delay) + "ms'}\n"

    tempstring4 += linkname
    tempstring4 += value
    temp4 =  '    net.addLink('
    temp4 += src_node
    temp4 += ', '
    temp4 += dst_node
    temp4 += ", cls=TCLink, **"
    temp4 += "CityLink"
    temp4 += str(citylinknum)
    temp4 += ")"
    temp4 += '\n'
    # Next line so i dont have to look up other possible settings
    # temp4 += "ms', loss=0, max_queue_size=1000, use_htb=True)"
    tempstring4 += temp4

    # Create address list
    if ip_switch_link_index % 254 == 0:
        ip_switch_link_base = ip_switch_link_base + 1
        ip_switch_link_index = 0

    ipv6_str1 = str(hex(ip_switch_link_base))[2:]
    ipv6_str2 = str(hex(ip_switch_link_index))[2:]

    address_list[f"s{src_id}"] = address_list[f"s{src_id}"] | {
        f"s{dst_id}": {
            "ip": f"10.{ip_switch_link_base}.{ip_switch_link_index}.1/24",
            "ipv6": f"fc00::{ipv6_str1}:{ipv6_str2}:1:0:0/80",
            # "bw": capacity
        }    
    }

    # ip_switch_link_index = ip_switch_link_index + 1
    address_list[f"s{dst_id}"] = address_list[f"s{dst_id}"] | {
        f"s{src_id}": {
            "ip": f"10.{ip_switch_link_base}.{ip_switch_link_index}.2/24",
            "ipv6": f"fc00::{ipv6_str1}:{ipv6_str2}:2:0:0/80",
            # "bw": capacity
        }    
    }
    ip_switch_link_index = ip_switch_link_index + 1
# ========================================================================================

outputstring_to_be_exported += tempstring4
outputstring_to_be_exported += outputstring_2e
outputstring_to_be_exported += tempstring6

if enable_ssh:

    ssh_string = '\n'

    # Create switch for ssh
    temp1 =  '    '
    temp1 += 'ssh_switch'
    temp1 += " = net.addSwitch('tmp1')\n"
    ssh_string += temp1

    for i, v in enumerate(nodes):
        node_name = v['node']

        temp2 =  '    net.addLink('
        temp2 += 'ssh_switch, '
        temp2 += node_name
        temp2 += "_host, "
        temp2 += "params1={'ip': '192."
        if i != 0 and i % 254 == 0:
            ip_host_base = ip_host_base + 1
        temp2 += str(ip_host_base)
        temp2 += '.'
        temp2 += str(i % 254 + 1)
        temp2 += '.1'
        temp2 += "/24'}, "
        temp2 += "params2={'ip': '192."
        temp2 += str(ip_host_base)
        temp2 += '.'
        temp2 += str(i % 254 + 1)
        temp2 += '.2'
        temp2 += "/24'}, "
        temp2 += "cls=TCLink)\n"
        ssh_string += temp2

        # temp3 =  '    '
        # temp3 += f"{id_node_name_dict[str(i)]}_host"
        # temp3 += ".cmd( '/usr/sbin/sshd -D -o UseDNS=no -u0 &' )\n"
        # ssh_string += temp3

    temp3 = '\n'
    temp3 += '    '
    temp3 += 'for host in net.hosts:\n'
    temp3 += '    '
    temp3 += '    '
    temp3 += "host.cmd( '/usr/sbin/sshd -D -o UseDNS=no -u0 &' )\n"
    ssh_string += temp3

    outputstring_ssh='''    info( '\033[1;36m*** Add ssh links\033[0m\\n')\n'''
    outputstring_to_be_exported += outputstring_ssh
    outputstring_to_be_exported += ssh_string

outputstring_to_be_exported += outputstring_3a
outputstring_to_be_exported += outputstring_3b
outputstring_to_be_exported += tempstring7
outputstring_to_be_exported += outputstring_write_nodes_json
outputstring_to_be_exported += tempstringController

# ========================================================================================
# write switch IP to switch_ip_list.json
for i in range(0, len(nodes)):

    ipv6_str1 = str(hex(ip_switch_base))[2:]
    ipv6_str2 = str(hex(((i % 254) + 1)))[2:]

    address_list[f"s{i+1}"] = address_list[f"s{i+1}"] | {
        f"lo": {
            "ip": f"10.0.{ip_switch_base}.{(i % 254) + 1}/32",
            "ipv6": f"fc00::{ipv6_str1}:{ipv6_str2}:1:0:0/128",
            "name": nodes[i]["node"]
        }    
    }

    address_list[f"s{i+1}"] = address_list[f"s{i+1}"] | {
        f"p4rt_s{i+1}": {
            "ip": f"192.168.{i+1}.1/24"
        }    
    }

# for i, v in address_list.items():    
#     print(i, ":", v)
file_path = "p4mininet/{name}_switch_ip_list.json"
with open(file_path.format(name=name), mode="wt", encoding="utf-8") as f:
        json.dump(address_list, f, ensure_ascii=False, indent=4)

# ========================================================================================

outputstring_to_be_exported += user_simulation_code_area
outputstring_to_be_exported += outputstring_4c
outputstring_to_be_exported += outputstring_4d

# GENERATION FINISHED, WRITE STRING TO FILE
output_file_name = 'p4mininet/' + 'os3e' + '_network.py'
outputfile = open(output_file_name, 'w')
outputfile.write(outputstring_to_be_exported)
outputfile.close()

print("Generate \033[0;33m" + "OS3E" + "\033[0m SUCCESSFUL! \033[0;36m" + \
      "(" + str(len(nodes)) + " Switches, " + \
      str(len(links)) + " Links)\033[0m")

print("")
print("*** NEXT STEP ***")
print("*** PLease Place Your Additional Simulation Code in the <USER SIMULATION CODE HERE> area of .py Runnable Topology File. ***")
